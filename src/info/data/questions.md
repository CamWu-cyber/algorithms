### 专业问题
1. 什么是闭环检测？常用的方法有哪些？你用的哪种方法？有没有创新？
2. 解释一下Gauss-Netwon和LM算法。
3. 熟悉Ceres优化库吗？说一下；g2o和ceres库都能用来进行BA优化，这两者在使用过程中有什么不同？
4. 描述（扩展）卡尔曼滤波与粒子滤波，你自己在用卡尔曼滤波时遇到什么问题没有？
5. 除了视觉传感，还用过其他传感吗？比如GPS，激光雷达。。。
6. 什么是紧耦合、松耦合？优缺点。
7. 你认为室内SLAM与自动驾驶SLAM有什么区别？
8. 地图点的构建方法有哪些？
9. 如果对于一个3D点，我们在连续帧之间形成了2D特征点之间的匹配，但是这个匹配中可能存在错误的匹配, 请问你如何去构建3D点？
10. RANSAC在选择最佳模型的时候用的metric是什么？
11. 除了RANSAC之外，还有什么鲁棒估计的方法？有哪几种鲁棒核函数？
12. 3D地图点是怎么存储的？表达方式？
14. 给你m相机n个点的bundle adjustment。当我们在仿真的时候，在迭代的时候，相机的位姿会很快的接近真值。而地图点却不能很快的收敛这是为什么呢？
15. LM算法里面那个 {\lambda} 是如何变化的呢？
16. 说一下3D空间的位姿如何去表达?
17. 李群和李代数的关系。
18. 求导\frac{\partial{R_1*R_2}}{\partial{R_1}}
19. 给你一个H高W宽的图像或者matrix，问如何去访问每一个元素，是先访问行呢？还是先访问列？跟缓存还有关系~
20. 写出单目相机的投影模型，畸变模型。
21. 说一个自己熟悉的SLAM算法，Lidar/Visual slam，说优缺点。
22. 读Maplab，设计室内服务机器人地图更新的方法、流程。
23. 安装2D lidar的平台匀速旋转的时候，去激光数据畸变，写代码
24. 给两组已经匹配好的3D点，计算相对位姿变换。已知匹配的ICP问题，写代码。
25. ORB-SLAM初始化的时候为什么要同时计算H矩阵和F矩阵？
26. 说一下Dog-Leg算法
27. 什么是边缘化？First Estimate Jacobian？一致性？可观性？
28. 说一下VINS-Mono的优缺点
29. 你做的工作在本质上有什么不同，贡献，创新本质上在哪里？
30. 什么是Essential，Fundamental矩阵？
31. 给定几个连续帧的带有位姿的帧，如何去测量车道线相对于世界坐标系的坐标。 
32. 在给定一些有噪声的GPS信号的时候如何去精准的定位？
33. 如何标定IMU与相机之间的外参数？
34. 给你xx误差的GPS，给你xx误差的惯导你怎么得到一个cm级别的地图。
35. 计算H矩阵和F矩阵的时候有什么技巧呢？实际上在问归一化的操作。
36. 给一组点云，从中提取平面。
37. 给一张图片，知道相机与地面之间的相对关系，计算出图的俯视图。
38. 双线性差值如何去做，写公式。
39. RGB-D的SLAM和RGB的SLAM有什么区别？
40. 机器人从超市门口出发，前往3公里外的小区送货。请你设计一个定位系统，包括传感器的配置、算法的流程，用伪代码写出来。
41. 什么是ORB特征，ORB特征的旋转不变性是如何做的，BRIEF算子是怎么提取的。
42. 如果把一张图像去畸变，写公式，流程。
43. ORB-SLAM中的特征是如何提取的？如何均匀化的？
45. [连通区域算法](https://link.zhihu.com/?target=http%3A//blog.csdn.net/icvpr/article/details/10259577)
46. [实现RANSAC的框架](https://github.com/MRPT/mrpt/libs/base/src/math/ransac.cpp)
47. Homography和Fundamentalmatrix的性质与区别
48. 简单实现cv::Mat()
49. 简述一下牛顿法、GN、LM等优化方法的区别
```
(1) GN: 线搜索
    将 f(x) 进行一阶泰勒展开，最后求解 H\delta{x} = b, 用 J^T*J 近似 H矩阵，省略了H复杂的计算过程
    ；稳定性差，可能不收敛；
(2) LM: 信赖区域
    求解 (H + I*\lambda)\delata{x} = b; 提供更稳定，更准确的增量。
```
50. 推导一下卡尔曼滤波，描述一下粒子滤
51. 描述一下SIFT或者SURF特征检测，匹配
52. 如何求解Ax=b
53. 简述一下Bundle Adjustment的过程、描述BA
```
(1) BA的本质是一个优化模型，其目的是最小化重投影/光度误差，用于优化相机位姿和世界点。
    局部BA用于优化局部的相机位姿，提高跟踪的精确度；全局BA用于全局过程中的相机位姿，
    使相机经过长时间、长距离的移动之后，相机位姿还比较准确。BA是一个图优化模型，
    一般选择LM(Levenberg-Marquardt)算法并在此基础上利用BA模型的稀疏性进行计算；
    可以直接计算，也可以使用g2o或者Ceres等优化库进行计算。
(2) Bundle Adjustment: 从视觉重建中提炼出最优的3D模型和相机参数（内参和外参），
    好似每一个特征点都会反射几束光线，当把相机位姿和特征点位置做出最优的调整后，
    这些光线都收束到相机相机光心。也就是根据相机的投影模型构造构造代价函数，
    利用非线性优化（比如高斯牛顿或列文伯格马夸而尔特）来求最优解，
    利用雅克比矩阵的稀疏性解增量方程，得到相机位姿和特征点3D位置的最优解。
(3) BA可以分为基于滤波器的BA和基于迭代的BA
```
54. 对熟悉的某一个开源SLAM，简述其流程
55. landmark参数化方式、对比，逆深度参数化(点、线、面、因子图优化)
```
(1) 点：逆深度表示
(2) 线：四个自由度，旋转 + 模长
```
56. 滤波+回环（Trifo-VIO）
```
(1) https://blog.csdn.net/hzwwpgmwy/article/details/81607963
(2) http://blog.sciencenet.cn/blog-465130-1086221.html
```
57. outlier+鲁棒核、RANSAC
58. EKF更新方程
59. [AR系统如何实现](https://blog.csdn.net/qq_27489007/article/details/78765810)
60. 介绍下VO
```
(1) 里程计一词来源于汽车，轮式里程计可以通过对车轮的转动可以得知汽车的运动距离。
    对于机器人而言，简单的说里程计就是机器人的运动轨迹，即求解机器人在每一时刻的位姿表示，
    有六个自由度
(2) 视觉里程计，机器人携带相机作为外传感器，根据实时的视频流，
    也就是相机图像信息估计机器人的位姿变换，即六自由度（位置和姿态），
    例如使用单目相机称为单目视觉里程计，两个相机称为立体视觉里程计。
```
61. Gridmap（网格标0、1）给定起点和终点，求最优路径(A\*或其他路径规划算法)
62. 相似变换、仿射变换、射影变换的区别
63. E和F的区别，自由度计算
```
(1) E的自由度为 3 + 3 - 1 = R_3 - t_3 - s_1 = 5
(2) F = K^{-T}*E*K^{-1}, 由于 K 可逆，所以不会对矩阵的秩产生影响，所以F与E同自由度
```
64. 单应矩阵H的求取
```
from 4.1.4 Solutions from lines and other entities, page 92
There is the question then of how many correspondences are required to compute the
homography (or any other relation). The general rule is that the number of constraints
must equal or exceed the number of degrees of freedom of the transformation. For
example, in 2D each corresponding point or line generates two constraints on H, in
3D each corresponding point or plane generates three constraints. 

Thus in 2D the correspondence of four points or four lines is sufficient to compute H, 
since 4 × 2 = 8, with 8 the number of degrees of freedom of the homography. 

In 3D a homography has 15 degrees of freedom, and five points or five planes are required. 
For a planar affine transformation (6 dof) only three corresponding points or lines are required, 
and so on. A conic provides five constraints on a 2D homography
```
65. PNP算法、ICP算法（二维码、手眼标定）、描述PnP
```
(1) Perspective-n-Points, PnP(P3P)提供了一种解决方案，它是一种由3D-2D的位姿求解方式，
    即需要已知匹配的3D点和图像2D点。目前遇到的场景主要有两个，
    其一是求解相机相对于某2维图像/3维物体的位姿；
    其二就是SLAM算法中估计相机位姿时通常需要PnP给出相机初始位姿。
(2) 在场景1中，我们通常输入的是物体在世界坐标系下的3D点以及这些3D点在图像上投影的2D点，
    因此求得的是相机坐标系相对于世界坐标系(Twc)的位姿
(3) 在场景2中，通常输入的是上一帧中的3D点（在上一帧的相机坐标系下表示的点）和这些3D点
    在当前帧中的投影得到的2D点，所以它求得的是当前帧相对于上一帧的位姿变换，如图所示：
    
(3) 两种情况本质上是相同的，都是基于已知3D点和对应的图像2D点求解相机运动的过程。
```
66. 闭环检测常用方法（orb、lsd、深度学习）
67. 单目的初始化（拓展：双目，RGBD，VIO的初始化及传感器标定）
68. 简述一下Bundle Adjustment的过程
69. SVO、LSD中深度滤波器原理、inverse compositional algorithm
```
(1) SVO深度滤波器原理
    首先假设传感器单次观测模型符合 高斯+均匀分布 混合模型
    主要参数包括：
        测量值为内点的概率为 \pi, 此时分布符合均值 为真正深度 Z 的高斯分布
        测量值为外点时概率为 1-\pi, 此时分布符合可能的最大深度和最小深度间的均匀分布
    p(x_n|Z,π) = πN(x_n|Z,τ_n^2) + (1−π)U(x_n|Zmin,Zmax) ---> (1)
    其中 \tau_n^2 为一个像素所代表的深度变化
    为了使用观测估计真实深度值，即后验，这里使用 Beta分布 与 高斯分布 近似后验分布
    q(Z,π|an, bn, µn, σn) := Beta (π|an, bn) N(Z|µn, σn2) 
    当有新的观测产生时，后验参数符合下式
    q(Z, π|a_new,b_new,µ_new,σ_new^2) = p(x|Z, π)q(Z, π|a_old,b_old,µ_old,σ_old^2) (2)
    然后将传感器观测模型 (1) 带入 (2) 可得
    q(Z, π|a_new,b_new,µ_new,σ_new^2) = 
            (πN(x|Z, σ_old^2) + (1-π)U(x))N(Z|µ_old, σ_old^2)Beta(π|a_old, b_old)  (3)
    然后使用等式 (3) 等号左边和右边分别计算关于待估计参数 Z 和 π 一阶、二阶距
    由此可建立 新的参数 与 旧的参数 之间的4个等式关系，正好解除四个新的参数
    即得到了参数的更新方程
```
```c++
// 之所以每次都要重新计算 \tau 的值
// 是因为这里涉及到两帧间的平移 t，而这是一个变量，故需要每次都重新计算 \tau
double DepthFilter::computeTau(
      const SE3& T_ref_cur,
      const Vector3d& f,
      const double z,
      const double px_error_angle)
{
  Vector3d t(T_ref_cur.translation());
  // 三角形的一个边
  Vector3d a = f*z-t;
  double t_norm = t.norm();
  double a_norm = a.norm();
  // 点乘公式反求三角形第一个内角
  double alpha = acos(f.dot(t)/t_norm);
  // 三角形第二个内角
  double beta = acos(a.dot(-t)/(t_norm*a_norm));
  // 对三角形原始第二个内角度进行一个像素角度的扰动
  double beta_plus = beta + px_error_angle;
  // 扰动后的三角形第三个内角
  double gamma_plus = PI-alpha-beta_plus;
  // 扰动后的深度
  double z_plus = t_norm*sin(beta_plus)/sin(gamma_plus);
  // 深度变化量
  return (z_plus - z);
}
```

70. 说一说某个SLAM框架的工作原理（svo、orb、lsd）及其优缺点，如何改进？
```
缺点：
    (1) 每幅图像计算orb特征，非常耗时
    (2) 三线程CPU负担较重，移植到嵌入式设备有困难
    (3) 稀疏图无法满足导航避障互动等
```
71. RANSAC的框架
72. 位姿不同表示间的相互转化、旋转矩阵特征值和特征向量物理意义
73. 真实世界到相机照片的变换可看成射影变换
74. 直接法、特征点法、光流法的优缺点对比
```
特征点法优点：
    (1) 运动过大时，只要匹配点还在像素内，则不太会引起无匹配，相对于直接法有更好的鲁棒性。
特征点发缺点：
    (1) 特征过多或过少都无法正常工作、环境特征少，或者提不出角点（如：渐变色）都无法工作
    (2) 只能用来构建稀疏地图、花很多时间在计算描述子和匹配上
直接法优点：
    (1) 只要关键点有梯度即可，可以在渐变的环境下工作、不需要计算描述子，不需要匹配特征点，节省了很多计算量。
    (2) 可以筹建半稠密乃至稠密的地图、稀疏的直接法可以做到非常快速的效果，适合real time和资源受限的场合
直接法缺点：
    (1) 图像无梯度，则对优化结果无贡献，特别如自动驾驶时候的天空
    (2) 基于灰度不变假设，容易受外界光照的影响。
    (3) 相机发生大尺度移动或旋转时无法很好的追踪，非凸优化，容易局部极值。用尺度金字塔改善。
    (4) 单个像素没有区分度，需要计算像素块，结果只能少数服从多数、容易受相机暗角影响
光流法优点：
    (1) 不需要计算描述子，不需要匹配特征点，节省了很多计算量、关键点提取的多少基本上都可以工作
    (2) 从稀疏到稠密重构基本上都可以使用
光流法缺点：
    (1) 基于灰度不变假设，容易受外界光照的影响。
    (2) 相机发生大尺度移动或旋转时无法很好的追踪，非凸优化，容易局部极值。用尺度金字塔改善局部极值，
        组合光流法（增加旋转描述）改善旋转
```
75. 常见滤波方法的对比（KF、EKF、IEKF、UKF、PF）
76. 双目测距范围Z=fb/d。问题： 640*480，fov＝90°，zmax＝10m，最小视差为2，求使zmax稳定的最小基线长度（6.25cm）
77. 特征点法与直接法误差模型、Jacobian推导
78. 光流的假设、仿射变换、4种方法，svo采取的方法，优势何在
```
SVO、PTAM仿射变换计算方法：
(1) 现将目标点从参考帧投影到当前帧
(2) 对参考帧目标点进行扰动，SVO是进行一个 halfpatch_size 的扰动，而 PTAM 是进行一个像素的扰动
(3) 将 u、v 方向上扰动后的点分别都应到当前帧
(4) 扰动后的当前帧坐标 - 目标点当前帧坐标，然后按列排放构成 4*4 的仿射变换矩阵
注：SVO计算得到的仿射每个列需要 除以 halfpatch_size
```
79. MSCKF与ROVIO、MSCKF与预积分（structureless factor）
80. 边缘化方式原理
81. [grid map](https://link.zhihu.com/?target=https%3A//github.com/ANYbotics/grid_map)
82. Homography和Fundamental Matrix的区别，包括二者区别，几个自由度，为什么是这么多自由度，怎么计算，这些在多视图几何那本书中都有
83. 视差与深度的关系。在相机完成校正后，则有d/b=f/z,其中d表示视差，b表示基线，f是焦距，z是深度
84. PNP算法、简述 EPnP 算法的大致步骤
85. ORBSLAM的初始化方式
86. ORB特征点与SIFT、SURF的区别、ORB特征点的特性
87. vins初始化是如何完成的？vins中是如何将IMU数据与camera融合到一起的？简述一下vins的大致框架
88. 简述一下ORBSLAM和vins的区别，如果你是开发者，你觉得这两个算法还有哪些可以改进的地方（选择其中一个也可）
89. 刚才提到你使用了一种名叫kalibr的相机内参标定工具，你提到这个工具也能进行camera-imu联合标定，能简述一下其思想吗？（此题没答上来，因为只会用没有深究其内部原理）
90. ORBSLAM中如何使用g20进行优化？
91. 特征点法与直接法的区别（以ORBSLAM和vins为例）
92. 你了解深度学习吗？你觉得深度学习和SLAM有哪些结合点？
93. 介绍一下各种传感器的特点（单目、双目、RGBD、激光）追问单目SLAM的缺陷以及如何解决
94. 你了解激光SLAM吗？能不能简述一下ICP算法的原理
95. 如何解决SLAM环境中动态对象的问题（具体事例为，餐厅来来往往的行人，这个时候送餐机器人估计的位姿受行人影响，会变得不够准确）
96. 你了解激光和视觉传感器的联合标定吗？有没有使用过相关的工具？
97. 你在简历中提到过一种轨迹误差评测工具（rpg_trajectory_evaluation）,能具体介绍一下原理吗？
98. 请你讲一下对极几何的知识以及基础矩阵的求解
99. [详细讲述一下vins中预积分的推导过程](https://zhuanlan.zhihu.com/p/65508067)
100. SLAM中为什么用李群李代数？为什么要引入李群李代数?
```
(1) 旋转矩阵自身是带有约束的，正交且行列式为1，他们作为优化变量时，会引入额外的约束，时优化变的困难，
    通过李群李代数的转换关系，把位姿估计变成无约束的优化问题。
```
101. 你了解图优化吗？能简单介绍一下吗？
102. 你了解ORBSLAM吗？能否具体介绍一下，你作为一名工程师，打算从那几个方面去优化它呢？或者有哪些可以创新的地方？
103. 你刚才提到vins的最新版本是vins_fusion，能具体介绍一下这个方案吗？
104. SLAM方向常用的技术要熟，RANSAC、pinhole camera model、reprojection error是必准备的，
     P3P、ICP、李群的基础知识（比如SO3）考的概率也很高。有些细节也可能考，比如RANSAC的iteration怎么算，P3P问题有几个解等。
105. SLAM中用的数值线性代数，比如QR、共轭梯度、舒尔补等。
106. 如何对匹配好的点做进一步的处理，更好保证匹配效果
```
(1) 确定匹配最大距离，汉明距离小于最小距离的两倍
(2) 使用KNN-matching算法，令K=2。则每个match得到两个最接近的descriptor，
    然后计算最接近距离和次接近距离之间的比值，当比值大于既定值时，才作为最终match。
(3) RANSAC(使用RANSAC找到最佳单应性矩阵。由于这个函数使用的特征点同时包含正确和错误匹配点，
    因此计算的单应性矩阵依赖于二次投影的准确性）
```
107. 单目相机，F和H矩阵有何不同，E和F矩阵有何不同，只旋转不平移能不能求F，只旋转不平移能不能求H
```
(1) E = t^R  F = K^{-T}*E*K^{-1}  H = R - t*n^{T} / d
(2) 在相机只有旋转而没有平移的情况，此时t为0，E也将为0，导致无法求解R，
    这时可以使用单应矩阵H求旋转，但仅有旋转，无法三角化求深度。
```
108. 关键帧在SLAM里应用非常多，很多知名的开源算法都使用了关键帧。请你用自己的语言描述一下关键帧是什么？有什么用？如何选择关键帧？
```
(1) 跟踪质量（主要根据跟踪过程中搜索到的点数和搜索的点数比例）/共视特征点
(2) 距离最近关键帧的距离是否足够远（空间）/运动
(3) 距离上一关键帧的帧数是否足够多（时间）

关键帧目前是一种非常常用的方法，可以减少待优化的帧数，并且可以代表其附近的帧。
可以理解为一个学校里有100个班级，每个班的班长就是一个关键帧，他可以代表他班里的人，
那么如何选取关键帧呢？
选取的指标主要有：
(1) 距离上一关键帧的帧数是否足够多（时间）
    比如我每隔固定帧数选择一个关键帧，这样编程简单但效果不好。比如运动很慢的时候，
    就会选择大量相似的关键帧，冗余，运动快的时候又丢失了很多重要的帧。
(2) 距离最近关键帧的距离是否足够远（空间）/运动
    比如相邻帧我根据pose计算运动的相对大小，可以是位移也可以是旋转或者两个都考虑，
    运动足够大（超过一定阈值）就新建一个关键帧，这种方法比第一种好。
    但问题是如果对着同一个物体来回扫就会出现大量相似关键帧。
(3) 跟踪质量（主要根据跟踪过程中搜索到的点数和搜索的点数比例）/共视特征点
    这种方法就是记录当前视角下的特征点数，或者视角，当相机离开当前场景时才会新建关键帧，
    避免了第2种方法的问题。缺点是比较复杂

打个比方，关键帧相当于slam的骨架，是在局部一系列普通帧中选出一帧作为局部帧的代表，记录局部信息。
举例来说，摄像头放在原处不动，普通帧还是要记录的，但关键帧因为总看到原场景，所以不会增加。
三角化需要一定程度的共视区域，所以普通帧每2帧之间会存在大量的信息冗余，如果所有帧全部参与计算，
不仅浪费了算力，对内存也是极大的考验，这一点在前端vo递归处理方式中表现不明显，
但在后端优化里是一个大问题，所以关键帧主要作用是面向后端优化的算力与精度的折中。此外，
关键帧选择时还会对图片质量、特征点质量等进行考察，一定程度上也发挥了滤波的作用，
防止无用的或错误的信息进入优化过程而破坏定位建图的准确性。
选择关键帧主要从关键帧自身和关键帧与其他关键帧的关系2方面来考虑。一方面，关键帧自身质量要好，
例如不能是非常模糊的图像、特征点数量要充足、特征点分布要尽量均匀等等；
另一方面，关键帧与其他关键帧之间的关系，需要和局部地图中的其他关键帧有少量的共视关系，
但大部分特征点是新特征点，以达到既存在约束，又尽量少的信息冗余的效果，
例如局部地图点投影到此帧的点数低于一个阈值或前一个关键帧的特征点在此帧里已经有90%观测不到等等。
在关键帧的运用上，我认为orbslam做的非常好，尤其是在回环检测中使用了以关键帧为代表的帧“簇”的概念，
回环筛选中有一步将关键帧前后10帧为一组，计算组内总分，以最高分的组的0.75为阈值，滤除一些组，
再在剩下的组内各自找最高分的一帧作为备选帧，这个方法非常好地诠释了“关键帧代表局部”的这个理念。
```
109. 什么是极线约束，按照你的理解讲解一下什么是极线约束？这个约束能带来什么好处？
```
所谓极线约束就是说同一个点在两幅图像上的映射，已知左图映射点p1，
那么右图映射点p2一定在相对于p1的极线上，这样可以减少待匹配的点数量。（画图解释）

极线约束也叫对极约束。这个约束的意思就是说，假设相机在不同位置拍摄了两幅图像，
如果一个空间点P在两幅图上分别有两个成像点，已知左图成像点为p1，
那么右图成像点p2一定在相对于p1的极线上。

（以上过程面试的时候最好画图解释一下，见附图，面试官会感觉你很专业）
极线约束的好处：从上面的描述我们可以看到，我们在做特征点匹配时，
左图成像点p1的待匹配点p2一定在相对于p1的极线上，
那么我们在做搜索时就可以在极线附近（考虑实际可能 会有一点误差）进行搜索，
相对暴力匹配极大减少待匹配的点的数量。
极线约束可以简洁的给出匹配点的空间位置关系，使得相机位姿估计问题变的简单。
```
110. 单目视觉slam中尺寸漂移是怎么产生的
```
(1) 单目相机根据一张图片无法得出一张图片中物体的实际大小，同理也就无法得出运动的尺度大小，
    这是产生尺度漂移的根源。而在优化过程中，单目相机使用对极几何中的三角测量原理，
    而三角测量中，极小的角度误差在累积之后深度不确定都会变得很大，从而无法保证尺度一致性。
```
111. SLAM中的绑架问题
```
(1) 绑架问题就是重定位，是指机器人在缺少之前位置信息的情况下，如何去确定当前位姿。
    例如当机器人被安置在一个已经构建好地图的环境中，但是并不知道它在地图中的相对位置，
    或者在移动过程中，由于传感器的暂时性功能故障或相机的快速移动，都导致机器人先前的位置信息的丢失，
    在这种情况下如何重新确定自己的位置。
```
112. 描述特征点法和直接法的优缺点
```
特征点法: 
特征点法，根据提取、匹配 特征点来估计相机运动，优化的是重投影误差，对光照变化不敏感 ，
是比较成熟的方案。常见的开源方案 比如ORBSLAM
优点:
    (1) 精确，直接法属于强假设;
    (2) 运动过大时，只要匹配点在像素内，则不太会引起误匹配，鲁棒性好
缺点:
    (1) 关键点提取、描述子、匹配耗时长
    (2) 特征点丢失场景无法使用
    (3) 只能构建稀疏地图
直接法：
直接法，根据相机的亮度信息估计相机的运动，可以不需要计算关键点和描述子，优化的是光度误差，
根据使用像素数量可分为稀疏、半稠密、稠密三种。常见开源方案有SVO, LSD-SLAM
优点：
    (1) 省去计算特征点、描述子时间
    (2) 可以用在特征缺失的场合(比如白墙)
    (3) 可以构建半稠密乃至稠密地图 
缺点：
    (1) 易受光照和模糊影响
    (2) 运动必须微小，要求相机运动较慢或采样频率较高(可以用图像金字塔改善)(PTAM::SBI)
    (3) 非凸性；单个像素没有区分度
```
113. 特征点法和直接法的BA有何不同
```
(1) 误差函数不同。特征点法是重投影误差，直接法是光度误差
(2) 雅克比矩阵不同
```
114. 光流和直接法有何不同
```
(1) 光流仅估计了像素间的平移, 没有用相机结构、没有考虑相机的旋转(VINS)和图像缩放、边界点追踪效果差
```
115. 特征匹配(稀疏)和稠密匹配区别
```
特征匹配：
    (1) 速度快，效率高，可以到亚像素级别，精度高
    (2) 匹配元素为物体的几何特征，对照明变化不敏感
稠密匹配:
    (1) 速度慢，效率低
    (2) 对无纹理区域匹配效果不理想，对光强条件敏感
```
116. EKF和BA的区别
```
(1) EKF假设了马尔科夫性，认为k时刻的状态只与k-1时刻有关。非线性优化使用所有的历史数据，
    做全体的SLAM(Full SLAM)
(2) EKF做了线性化处理，在工作点处用一阶泰勒展开式近似整个函数，但在工作点较远处不一定成立。
    非线性优化每迭代一次，状态估计发生改变，我们会重新对新的估计点做泰勒展开
    可以把EKF看做只有一次迭代的BA 
```
117. 视觉SLAM常用的相机包括，单目，双目，RGB-D相机，请分别说说它们本身的优缺点、常用的相机型号等
```
单目: 成本低，搭建简单，单目相机有尺度不确定性，需要专门初始化
双目: 不需要专门初始化，能够计算深度，基线距离越大，测量距离越远，可以用于室内和室外，
      标定较为复杂，视差计算比较消耗资源
深度: 测量范围窄，噪声大，易受日光干扰，无法测量透射材料，主要用于室内

以下是我使用时的一些总结，可能有疏漏错误，欢迎补充指正。
单目相机：
常用型号：有非常多的种类可以选择
优点：
1、应用最广，成本可以做到非常低。
2、体积小，标定简单，硬件搭建也简单。
3、可以用于室内和室外（有适当光照条件下）。
缺点：
1、具有纯视觉传感器的通病：在光照变化较大，纹理特征缺失、快速运动导致模糊的情况下无法使用（睁眼瞎）。
2、SLAM过程使用单目相机有尺度不确定性，需要专门初始化。
3、必须通过运动才能估计深度（帧间匹配三角化）
双目相机：
常用型号：Indemind，小觅，ZED等
优点：
1、相比于单目，在静止时就能够根据左右相机视差图计算深度。
2、可测量距离可以根据基线调节。基线距离越大，测量距离越远。
3、可以用于室内和室外（有适当光照条件下）。
缺点：
1、双目相机标定相对复杂
2、用视差计算深度比较消耗资源
3、具有纯视觉传感器的通病：在光照变化较大，纹理特征缺失、快速运动导致模糊的情况下无法使用（睁眼瞎）。
RGB-D相机：
常用型号：Kinect系列、Realsense系列、Orbbec、Pico等
优点：
1、使用物理测距方法测量深度，所以避免了纯视觉传感器的通病，在没有光照的情况下、
   快速运动的情况下都可以测距。这是非常大的优势。
2、相对双目，输出帧率较高，更适合运动场景。
3、输出深度值比较准，结合RGB信息，容易实现手势识别、人体姿态估计等应用。
缺点：
1、测量范围窄，易受日光干扰，通常只能用于室内场景
2、在遇到透射材料、反光表面、黑色物体情况下表现不好，造成深度图缺失
3、通常分辨率无法做到很高，目前主流分辨率VGA（640x480）
4、标定比较复杂。
```
118. 常用的边缘检测算子和优缺点
```
(1) 边缘检测一般分为三步，分别是滤波、增强、检测。基本原理都是用高斯滤波器进行去噪，
    之后在用卷积内核寻找像素梯度。常用有三种算法：canny算子，sobel算子，laplacian算子
(2) canny算子：一种完善的边缘检测算法，抗噪能力强，用高斯滤波平滑图像，
    用一阶偏导的有限差分计算梯度的幅值和方向，对梯度幅值进行非极大值抑制，采用双阈值检测和连接边缘。
(3) sobel算子：一阶导数算子，引入局部平均运算，对噪声具有平滑作用，抗噪声能力强，计算量较大，
    但定位精度不高，得到的边缘比较粗，适用于精度要求不高的场合。
(4) laplacian算子：二阶微分算子，具有旋转不变性，容易受噪声影响，不能检测边缘的方向，
    一般不直接用于检测边缘，而是判断明暗变化。
```
119. 一阶梯度下降，G-N和L-M三种方法的关系
```
(1) (H+I\lambda)\delta{x} = b
(2) 当 \lambda = 0 时， L-M 等于 G-N; 当 \lambda = ∞ 时，L-M 等于 一阶梯度下降
(3) L-M的好处就在于：如果下降的太快，使用较小的λ，如果下降的太慢，使用较大的λ
```
120. 为什么SLAM中常用L-M
```
(1) G-N中的H矩阵可能为奇异矩阵或者病态矩阵，导致算法不收敛。而且当步长较大时，也无法保证收敛性，
    所以采用L-M求解增量方程，但是它的收敛速度可能较慢。
```
121. 介绍RANSAC算法
```
(1) RANSAC算法的基本假设是样本中包含正确数据(inliers，可以被模型描述的数据)，
    也包含异常数据(outliers，偏离正常范围很远、无法适应数学模型的数据)，
    即数据集中含有噪声。这些异常数据可能是由于错误的测量、错误的假设、错误的计算等产生的。
    同时RANSAC也假设，给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。
(2) 优缺点：
    RANSAC算法的优点是能鲁棒的估计模型参数。
    例如，他能从包含大量局外点的数据集中估计出高精度的参数。缺点是它计算参数的迭代次数没有上限，
    如果设置迭代次数的上限，得到的结果可能不是最优的结果，甚至可能得到错误的结果。
    RANSAC只有一定的概率得到的可信的模型，概率与迭代次数成正比。另一个缺点是它要求设置跟问题相关的阈值，
    RANSAC只能从特定的数据集中估计出一个模型，如果存在两个（或多个）模型，RANSAC不能找到别的模型。
```
122. 如何优化重投影误差？采用什么方法求解？如果误匹配的点重投影之后误差很大，如何解决它对整个优化问题的影响？
```
(1) 图优化模型，将路标点和相机位姿作为两个节点，观测模型作为边，同时优化两个变量
(2) SLAM中常用L-M求解，如果误匹配误差很大可以考虑用核函数（Huber）
```
123. [重投影误差的表达式，误差关于位姿的偏导数怎么算？误差关于空间点的偏导数怎么计算](https://pic4.zhimg.com/80/v2-08210a84a853a87ea13dbc944c9cf0eb_hd.jpg)
124. g2o工程化的注意事项
```
(1) 图优化流程：
    ①选择节点和边，确定参数化形式
    ②加入节点和边
    ③选择初值，开始迭代
    ④计算J和H
    ⑤解H△x = -b
    ⑥GN/LM
    g2o需要实现其中的③-⑥
(2) g2o
    ①选择线性方程求解器（PCG/Cspare/Choldmod）
    ②选择一个blockslover③选择迭代方式（GN/LM/Dogleg）
(3) 实现过程 ：
    选择节点和边 
    节点：g2o :: VertexSE3Expmap（相机位姿）
    g2o :: VertexSBApointXYZ（路标）
    边：g2o :: EdgeProjectXYZ2UV（重投影误差）
```
125. 做图优化时，对比采用四元数法和李代数法在数学直观性、计算量上的差异性
126. 优化求解过程中，g2o或者ceres的内部实现过程，有哪些加速计算的处理
127. 画后端优化因子图
128. 边缘化的过程全面分析，示意图，公式推导，优缺点，哪些矩阵块有改变
129. 10个相机同时看到100个路标点，问BA优化的雅克比矩阵多少维
```
2000*360
```
130. 解释相机内外参数
```
(1) 相机内参包括焦距fx，fy，cx，cy，径向畸变系数k1,k2,k3，切向畸变系数p1,p2其中内参一般来说是不会改变，
    但是当使用可变焦距镜头时每次改变焦距需要重新标定内参当图像裁剪时内参cx，cy会发生改变，
    比如图像从8*8变成4*4时，cx，cy需要除以2一般标定工业相机时只需要得到畸变系数k1，k2即可，
    对于畸变系数较大的鱼眼相机需要得到k3，p1，p2相机外参分为旋转矩阵R和平移矩阵t，
    旋转矩阵和平移矩阵共同描述了如何把点从世界坐标系转换到摄像机坐标系
```
131. 工程目录下有GPS保存的坐标文件gps.txt和激光雷达保存的坐标文件laser.txt两个文件，
     两个文件的第一列为记录当前数据的时间戳，后两列为坐标。由于GPS每隔500时间单位保存一次数据，
     激光雷达每隔300时间单位保存一次数据，因此，一段时间内激光雷达保存的数据比GPS保存的数据要多。
     现在想取出两个文件中时间戳最接近的数据，并分别存放在gps2.txt和laser2.txt中，编写程序实现。
132. 我们知道相机的内参有 fx, fy, cx, cy, 畸变参数(只考虑k1, k2)，相对世界坐标原点外参T。
     如果我们现在对相机拍摄的图片进行2倍的下采样，那么这些参数会如何变化？
133. OC-EKF 中的可观性约束
134. 各种雅克比矩阵的计算

### 算法数据结构&C++
1. ORB-SLAM的共视图是什么结构？内部如何存储的？
2. 写一个四叉树的结构
3. 不用递归遍历二叉树
4. 求最大连通域
5. 多线程的实现方式
6. std::vector描述一下，如何动态扩展，如何shink内存
7. Eigen是行优先还是列优先
8. unorder容器与ordered容器的区别说一下
9. Mat是如何析构的
10. 说一下智能指针，shared_ptr与unique_ptr
11. 说一下什么是虚函数
12. 普通指针如何实现一块内存只能有一个指针指向这种功能
13. C++ RTTI 是什么东西？
14. C++是如何实现多态的？
15. vector的iterator什么时候失效？
16. 重建二叉树
17. 写CmakeLists.txt，写gcc指令
18. 一个图，给出两个一对的若干节点对，求两个节点之间的通路。
19. 实现一个稀疏矩阵的数据结构，并实现稀疏矩阵的加法。
20. 棋盘格，每个格子角点上有一个灯，按一下周围四个灯就会取反。开始的时候这个棋盘格上灯状态随机，问如何操作这些按钮可以使得整个棋盘全灭。
21. 编一个二分查找
22. 给你一个数组去排序，说排序算法
23. 给你2D平面的两个线段，判断两个线段是否相交
24. 写快速排序、写反转链表
25. 给两个排序数组，升序的。一个大小为n，一个大小为m。从中找出第k小的数字。
26. 多线程的了解，stl有什么？
```
(1) C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，
    这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。核心包括三个组件：
    容器、算法、迭代器
(2) C++中有两种类型的容器：顺序容器和关联容器，顺序容器主要有：vector、list、deque等。
    其中vector表示一段连续的内存地址，基于数组的实现，list表示非连续的内存，基于链表实现。
    deque（双端队列）与vector类似，但是对于首元素提供删除和插入的双向支持。关联容器主要有map和set。
    map是key-value形式的，set是单值。map和set只能存放唯一的key值，multimap和multiset可以存放重复key值。
    vector 的底层为顺序表（数组），list 的底层为双向链表，deque 的底层为循环队列，set 的底层为红黑树，
    hash_set 的底层为哈希表。
```
27. vector扩充方式，size与capacity区别
```
(1) size 是当前 vector 容器真实占用的大小，也就是容器当前拥有多少个容器。
(2) capacity 是指在发生 realloc 前能允许的最大元素数，即预分配的内存空间。
(3) 当然，这两个属性分别对应两个方法：resize() 和 reserve()。
    使用 resize() 容器内的对象内存空间是真正存在的。
    使用 reserve() 仅仅只是修改了 capacity 的值，容器内的对象并没有真实的内存空间(空间是"野"的)。
    此时切记使用 [] 操作符访问容器内的对象，很可能出现数组越界的问题。
```
28. 顺序存储结构有哪些？
```
(1) 顺序存储结构: vector, list, deque
(2) 关联存储结构: set，map，multiset，multimap
```
29. 左值引用与右值引用
```
(1) 在C++11中，区别表达式是左值或右值可以做这样的总结：当一个对象被用作右值的时候，用的是对象的值（内容）；
(2) 当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。左值有持久的状态，而右值要么是字面常量，
    要么是在表达式求值过程中创建的对象，即左值持久，右值短暂
(3) 不能将一个右值引用直接绑定到一个左值上
```
30. map与unordered map区别
```
(1) 都属于关联容器，存储元素的类型都为Key-Value。也就是pair<key, value>。 map底层基于红黑树实现，排好序的；
    unordered_map底层是基于散列表实现，是无序的。两者的头文件分别是; 
(2) 两者都是不允许重复的key出现的，重复的版本为multimap和unorderd_multimap.   
```
31. const与static、const在函数前与函数后区别、const在不同位置的含义
```
(1) 一个函数在定义时前面加上static，该函数只能被本源文件调用; 在成员函数前面加static，则为静态成员函数，
    静态成员函数用于操作静态数据成员，为类而不是类的对象服务。一般调用用“类名::静态成员函数()”.
(2) static修饰变量时，变量存储在全局变量去，分为局部静态变量和全局静态变量，
    静态的全局变量则只有该源文件可以共享某一全局变量，
    静态局部变量存储在全局变量区，函数结束时变量不消亡，继续上次调用函数时的结果，程序结束时再消亡
(3) 在类的定义中，如果一个成员函数在函数的后面加关键字 const，说明为常量成员函数，在函数定义时也要加const 
    常量成员函数不会修改''类的数据成员''，任何不修改数据成员的成员函数都应该被声明为const类型，
    这样如果编写程序时出现相应错误编译器会报错，提高了程序的健壮性。
(4) const加在函数的前面。   修饰函数的返回值，说明返回值是常量
```
32. 虚函数与纯虚函数区别，虚函数关键字
```
(1) 虚函数可以实现多态，基类中的虚函数必须实现，即使为空也要实现
(2) 纯虚函数用来定义接口，子类要想实例化必须实现父类的纯虚函数
```
33. 函数memcpy 、memset的实现，手撕代码
34. 一行代码求平方根
35. 各种排序时间空间复杂度（快排，归并，桶排，堆排），手撕代码
36. 二叉树排序、堆排序、希尔排序、桶排序时间复杂度（重要！因此重复）
37. 最长公共子串、最长公共子序列，手撕代码
38. 树的DFS与BFS、树的遍历，手撕代码
39. 对于n个实例的k维数据，建立kd tree的时间复杂度
40. 哈夫曼树带权路径长度、哈夫曼编码
41. 长度为n的list，删除、插入与随机访问的计算复杂度
42. 在有序表中二分查找关键字所需进行的关键字比较次数是多少？
43. 字符串子串数目
44. 三维空间最近邻搜索的常用数据结构（八叉树、kd tree）
45. HashMap和Hashtable的
46. 比较在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。
    请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数
47. 简述堆和栈的区别、虚函数和纯虚函数的区别
78. 你用过容器吗（具体指vector），你觉得他有哪些特点？
79. 你了解c++各种设计模式吗？
80. static关键字的作用
81. 你用过智能指针吗？分别都有什么特点呢？
82. C++多态
```
(1) 静态多态(重载, 模板)
    是在编译的时候，就确定调用函数的类型
(2) 动态多态(覆盖, 虚函数实现)
    在运行的时候，才确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数
(3) 虚函数就是允许被其子类重新定义的成员函数。而子类重新定义父类虚函数的做法
    称为"覆盖"（override），或者称为"重写"
(4) 重载，是指允许存在多个同名函数，而这些函数的参数表不同
    或许参数个数不同，或许参数类型不同，或许两者都不同
```

### 数学问题
1. 一层楼共有n级台阶，一次可以上至少一级但不超过m级台阶，求有多少种不同的上楼方案数。由于结果可能很大，你只需要输出结果对10007取模的值即可
2. 拟合二维平面中的带噪声直线，其中有不超过20%的样本点远离了直线，另外80%的样本点可能有高斯噪声的偏移，要求输出为ax+by+c=0的形式，其中a>0且a^2+b^2=1
3. 切比雪夫不等式、协方差与相关系数、各种分布、多元高斯分布
4. 线性回归推导回归系数（y=kx，y=kx+b）
5. 甲乙两人约好在某地碰面，时间段为10点到11点。若甲先到，最多会等待10分钟，10分钟内乙未出现则离开；若乙先到，最多会等待15分钟，15分钟内甲未出现则离开，请问两人见面的概率是多少？
6. ABCDE5个人互相传球，由A开始第一次传球，经5次传球最后回到A的手上，其中A与B不会互相传球，C只会传给D，E不会传给C，共有多少种传球方法？
7. 平均要取多少个(0,1)中的随机数才能让和超过1
8. MLE、MAP和贝叶斯估计
9. MLE，MAP，EM 和 point estimation 之间的关系是怎样的？
10. 如何求解Ax=b (非迭代Cholesky分解、QR分解，迭代)
11. 最小二乘封闭解与迭代解的取舍
12. 梯度下降法、牛顿法、GN、LM，推导、优缺点
13. 如何判断点在多边形内
14. 一阶、二阶优化，Jacobian、hessian矩阵
15. 1000个数的阶乘，求有多少个0
16. 递推法求数学期望，反证法，数学归纳法等

### 传统图像处理问题
1. [图像平滑算子、边缘检测算子](https://www.cnblogs.com/lynsyklate/p/7881300.html)
```
Roberts(交叉梯度算子): 对具有陡峭的低噪声图像处理效果较好，但提取的边缘较粗，因此边缘定位不准确
       Roberts交叉梯度算子由两个2×2的模版构成 [-1, 0; 0, 1] [0, -1; 1, 0]
Sobel: 对灰度渐变和噪声较多的图像处理效果较好，Sobel算子对边缘定位比较准确，Sobel算子根据像素点上下、左右邻点灰度加权差，
       在边缘处达到极值这一现象检测边缘。对噪声具有平滑作用，提供较为精确的边缘方向信息，边缘定位精度不够高。
       当对精度要求不是很高时，是一种较为常用的边缘检测方法。相比Prewitt他周边像素对于判断边缘的贡献是不同的.
       [-1, -2, -1; 0, 0, 0; 1, 2, 1] [-1, 0, 1; -2, 0, 2; -1, 0, 1]
Kirsch: 对灰度渐变和噪声较多的图像处理效果较好
Prewitt: 对灰度渐变和噪声较多的图像处理效果较好, Prewitt算子是一种3×3模板的算子,它有两种形式,分别表示水平和垂直的梯度
         [-1, -1, -1; 0, 0, 0; 1, 1, 1] [-1, 0, 1; -1, 0, 1; -1, 0, 1]
Laplacian: 对图像中的阶跃性边缘点定位准确，对噪声非常敏感，丢失一部分边缘的方向信息，噪声检测的边缘不连续
LoG: 对噪声敏感，很少用于边缘检测，而是用来判断边缘像素是位于图像的明区还是暗区，可以使用DOG近似
Canny: 不易受噪声的干扰，能够检测到真正的弱边缘，Canny是最有效的边缘检测方法，优点在于使用两种不同的阈值分别
       检测强边缘和弱边缘，且仅当弱边缘与强边缘相连时才使用弱边缘，因此该方法不容易被噪声干扰，容易检测真正的弱边缘
       Canny边缘检测算法的实现较为复杂,主要分为以下步骤       
       (1)高斯模糊
       (2)计算梯度幅值和方向
       (3)非极大值 抑制
       (4)滞后阈值
```
2. 图像去噪滤波算法（高斯、均值、双边、Guide filter）
3. [三个度量patch相似度的方法(SSD、SAD、NCC)](https://blog.csdn.net/hujingshuang/article/details/47759579)
```
平均绝对差算法(MAD: Mean Absolute Differences):
子图与模板图对应位置上，灰度值之差的绝对值总和，再求平均，实质：是计算的是子图与模板图的L1距离的平均值
缺点: 对噪声非常敏感

绝对误差和算法(SAD: Sum of Absolute Differences):
与MAD类似，少了求均值这一步

误差平方和算法(SSD: Sum of Squared Differences):
实际上，SSD算法与SAD算法如出一辙，只是其相似度测量公式有一点改动（计算的是子图与模板图的L2距离）

平均误差平方和算法(MSD: Mean Square Differences):
比SSD多了一个求均值的步骤，其他相同

归一化积相关算法(NCC: Normalized Cross Correlation):
\frac{\Sigma\Sigma{S(i, j)*T(i, j}}{\sqrt{\Sigma\Sigma{S(i, j)^2*T(i, j}^2}}

序贯相似性检测算法(SSDA: Sequential Similiarity Detection Algorithm):
(1) 误差计算为对应位置的去均值光度误差绝对值
(2) 设定阈值 Th
(3) 在模板中随机选择不重复的像素点，计算误差累计和，当误差累加值超过了Th时，记下累加次数H，并停止对该 patch 的计算
(4) 在计算过程中，随机点的累加误差和超过了阈值（记录累加次数H）后，则放弃当前子图转而对下一个子图进行计算。
    遍历完所有子图后，选取最大R值所对应的(i,j)子图作为匹配图像【若R存在多个最大值（一般不存在），
    则取累加误差最小的作为匹配图像】。

ZMSSD:
(1) SA = mnTemplateSum
(2) SB = nImageSum
(3) N = mnPatchSize * mnPatchSize   nCrossSum += n * templatepointer[nCol]
(4) ZMSSD = ((2*SA*SB - SA*SA - SB*SB)/N + nImageSumSq + mnTemplateSumSq - 2*nCrossSum)
```
4. 二进制描述子
5. 计算描述子距离函数
6. 描述一下SIFT或者SURF特征检测、匹配
7. SIFT的4个不变性
8. 特征点、描述子ORB、SIFT、SURF、BRIEF等等 。geometric invariance：平移，旋转，尺度……; photometric invariance：亮度，曝光……
9. Mat实现、Mat类指针引用复制函数
10. 颜色直方图统计，手撕代码
11. 形态学操作，手撕代码
12. 积分图，手撕代码连
13. 通区域算法，给二值图，求出最大联通区域（用深度优先和广度优先算法，手撕代码）
14. Mser、Swt检测
15. 图像分割（Grabcut）
16. 目标跟踪（相关滤波KCF）
17. 直方图均衡化图像

### 非技术问题
1. 自我介绍、性格缺点、最有成就感的经历、最大的挫折之类、职业规划、为什么选择我们公司等问题，一定要准备到滚瓜烂熟。

### Offer
1. package价钱都是可以谈的，怎么谈上网搜，有很多技巧
2. offer的deadline一般都不是死的，都可以和HR谈，不要被HR要求deadline之前回复吓到，这都是HR的技巧。
3. 如果最后多个offer可以选，先选出最想去的几家列个final list，然后要求HR再安排和hiring manager的电话。做决定的最后关头，有些面试过程中获取的信息以及感觉可能已经记不清了，最后的fresh information and feel会很有帮助。
4. 最后几天一定要和final list上所有公司通话，以防被一两家公司带跑偏。
5. 最后几点有关做决定：1、人都是感性动物，很难完全理性；2、你获取的所有信息都是有bias，不管是公司人员还是第三方，每个人所处的位置不同，他们得到的（以及决定告诉你的）信息都会有或主观或客观的bias；3、你永远无法获得全面的信息来帮助你做决定，无论你如何努力八卦，你手里永远都是很少一部分充斥着bias的信息。
6. 所以说，谁也没有办法能客观准确的做决定，决定怎么做永远是非常主观的事情。